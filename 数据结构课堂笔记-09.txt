数据结构课堂笔记-09
程序测试，分析结果，找出原因，修改程序。
比如：
1）链栈中的Push()函数，如果没有返回值，会如何？
LS的值传给了形参变量top,在Push函数中改变top的值，LS的值仍然没变化。
所以Push函数需要返回top的值。

2）链栈的getTop()函数测试时，prinft("%d,%d\n",getTop(LS,&x),x);
    可能会发现输出结果与预期的结果不一致，分析原因，找出问题所在，并改进！  
    经过其它类型的测试，发现printf("...",参数列表); 从右向左依次求解每个参数列表中的值！！！

3)要求每个课内实验，都要严格按实验报告模板中的规定，认真完成，并撰写实验报告！

新知识点：队列
队列的概念：只允许在一端插入，在另一端删除的线性表。
队尾：允许插入的端
队头：允许删除的端
ADT:操作的总称
   置空队列
   销毁队列
   判断队空
   入队
   出队
   取队头元素
以上每种操作的实现，与其存储结构密切相关。

顺序队列：以顺序方式存储的队列
链队列：以链接方式存储的队列

顺序队列：
一维数组,ElemType data[Max];
int rear,front;
rear:队尾元素的实际下标
front:是队头元素左边(前面)一个位置的下标。
队空时，front==rear

开始时，置空队列，front=rear=-1
x入队时，rear++,data[rear]=x;=>    data[++rear]=x;
出队时，front++,取出原来的队头元素值，赋值给x的指向
如果rear==Max-1,认为队满，不能入队。但如果出队，可以一直出队直到front==Max-1,实际上是队空。
所以，上述存储方式，存在着队列假满(上溢,upperFlow)的情况。
为了有效地解决队列假上溢的情况，采用循环结构的顺序队列！
初始化时，front=rear=Max-1,
队空：front==rear
入队时，rear要在循环意义下加1,即 ( rear+1)%Max=>rear
出队时，front要在循环意义下加1,即 ( front+1)%Max=>front
队满时，也出现了rear==front

当front==rear时，无法区分到底是队空，还是队满！
为了让front==rear作为队空的唯一条件，规定不允许队列真满！！！
当rear即将追上front时(差一步)时，认为队满！
当(rear+1)%Max==front时，我们认为队满！
牺牲了一个元素的空间，表示队满






















