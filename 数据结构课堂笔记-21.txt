数据结构课堂笔记-21

带权路径长度WPL：
设二叉树具有n0个带权值的叶结点，那么从根结点到各个叶结点的路径长度与相应结点权值的乘积的和，叫做二叉树的带权路径长度--WPL。
哈夫曼树（也称最优树）:具有最小带权路径长度的二叉树.
给定一组权值给叶子结点，构成二叉树，让二叉树的WPL最小，这样的二叉树，称为哈夫曼树--优化二叉树。
构造过程：
假设，给定了一组带有权值的叶子结点，权值分别为7,3,5,9,8
详见录屏的视频图解

哈夫曼编码：规定哈夫曼树中的左分支为0，右分支为1，则从根结点到每个叶结点所经过的分支对应的0和1组成的序列便为该结点对应字符的编码。

任意给定一组带有权值的叶子结点，能正确构造哈夫曼树，进行哈夫曼编码，计算WPL

一道考题：设哈夫曼编码的长度不超过4，若已对两个字符编码为1和01，则最多还可对（  ）个字符编码。

n个叶子结点，所构造的哈夫曼树，共有2n-1个结点
定义数组，数组元素的个数必须是常量
n是变量
动态开辟若干个可变长度的空间，malloc()
int m=10;
struct node data[m];//语法错，m不能是变量！
int *p[3];
int a,b,c;
p[0]=&a;

struct node * p;
p=(struct node *)malloc(sizeof(struct node)*(2*n-1));
int i;
for(i=0;i<2*n-1,++i)
    p[i].rChild=p[i].lChild=p[i].parent=-1;
for(i=0;i<n;++i)
   scanf("%f",&p[i].weight);

数据类型定义
struct node{
    float weight;//结点的权值
    int parent,lChild,rChild;//分别表示双亲结点、左孩子结点、右孩子结点的下标
};



