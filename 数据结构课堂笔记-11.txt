数据结构课堂笔记-11

链栈的出栈函数的修改
如何在主函数中进行测试

上一讲，链队列，出队算法，改进：释放头结点，而不是释放队头元素所在的结点，这样可使出队算法统一、简单。不需要修改rear指针。
int deQueue2(linkQueue *lq,ElemType *x){
	if(lq->front==lq->rear){printf("队空\n");return 0;	}
	Node *p=lq->front;
	lq->front=p->next;
	free(p);
	*x=lq->front->data;
	return 1;
}

MOOC上的迷宫算法，大家课外自学，并编程上机测试！！！
估计每人至少要视频不回看5遍以上，边看边暂停，画图解。

目前为止的基本数据结构：
顺序表、单链表(带头结点、不带头结点、带头结点的循环单链表-只设rear指针)
栈：顺序栈(栈底在向量低端、高端，双栈)、链栈(不用带头结点的单链表)
队列：顺序队列(采用循环结构)、链队列(用带头结点的单链表)

课外补充练习：1.用带头结点的循环单链表存储链队列，只设rear指针
             2.顺序队列，
                ElemType data[Max];
                int len,rear;
          
